<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMG Monitor - Sistema de Monitoreo de Costos Marginales</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Supabase for auth -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="/js/auth.js"></script>

    <!-- Plotly for charts -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    
    <style>
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .status-live { background-color: #10b981; }
        .status-recent { background-color: #f59e0b; }
        .status-stale { background-color: #ef4444; }
        .status-updating { 
            background-color: #3b82f6;
            animation: pulse 0.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .chart-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 400px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-blue-50 min-h-screen" style="visibility: hidden;">
    <!-- Header -->
    <header class="bg-white shadow-lg">
        <div class="container mx-auto px-4 py-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">
                        ‚ö° CMG Monitor - Chilo√©
                    </h1>
                    <p class="text-gray-600 mt-2">
                        Sistema de Monitoreo de Costos Marginales en Tiempo Real
                    </p>
                </div>
                <div class="flex items-center gap-4">
                    <div class="text-right">
                        <div class="flex items-center gap-2">
                            <span id="status-indicator" class="status-indicator status-updating"></span>
                            <span id="status-text" class="font-semibold">Inicializando...</span>
                        </div>
                        <p id="last-update" class="text-sm text-gray-500">
                            Conectando...
                        </p>
                    </div>
                    <div class="flex gap-2">
                        <a href="optimizer.html"
                           class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                            <span>Optimizaci√≥n</span>
                        </a>
                        <a href="ml_config.html"
                           class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
                            </svg>
                            <span>ü§ñ ML Config</span>
                        </a>
                        <a href="forecast_comparison.html"
                           class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                            <span>üîÆ Comparar Pron√≥sticos</span>
                        </a>
                        <a href="rendimiento.html"
                           class="bg-orange-600 hover:bg-orange-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                            <span>üìä Rendimiento</span>
                        </a>
                        <button onclick="logout()"
                                class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                            </svg>
                            <span>Salir</span>
                        </button>
                        <!-- Actualizar button hidden
                        <button id="refresh-btn" onclick="manualRefresh()" 
                                class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2"
                                style="display: none;">
                            <svg id="refresh-icon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                      d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                            </svg>
                            <span id="refresh-text">Actualizar</span>
                        </button>
                        -->
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Loading States -->
    <div id="loading-container" class="container mx-auto px-4 py-8">
        <div class="bg-white rounded-xl shadow-lg p-8">
            <div class="flex flex-col items-center justify-center">
                <div class="loading-spinner mb-4"></div>
                <h2 id="loading-stage" class="text-xl font-semibold text-gray-700 mb-2">
                    Inicializando sistema...
                </h2>
                <p id="loading-detail" class="text-gray-500">
                    Conectando con el servidor...
                </p>
            </div>
        </div>
    </div>

    <!-- Main Content (hidden initially) -->
    <div id="main-content" class="container mx-auto px-4 py-8 hidden">
        <!-- Statistics Cards -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-gray-500 text-sm font-medium mb-2">CMG Actual</h3>
                <p id="current-cmg" class="text-3xl font-bold text-blue-600">--</p>
                <p id="current-time" class="text-xs text-gray-400 mt-1">--</p>
            </div>
            
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-gray-500 text-sm font-medium mb-2">Promedio 24h</h3>
                <p id="average-cmg" class="text-3xl font-bold text-green-600">--</p>
                <p class="text-xs text-gray-400 mt-1">√öltimas 24 horas</p>
            </div>
            
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-gray-500 text-sm font-medium mb-2">M√°ximo 24h</h3>
                <p id="max-cmg" class="text-3xl font-bold text-red-600">--</p>
                <p id="max-time" class="text-xs text-gray-400 mt-1">--</p>
            </div>
            
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-gray-500 text-sm font-medium mb-2">Cobertura</h3>
                <p id="coverage" class="text-3xl font-bold text-purple-600">--%</p>
                <p id="nodes-available" class="text-xs text-gray-400 mt-1">-- nodos</p>
            </div>
        </div>

        <!-- Node Selector -->
        <div class="bg-white rounded-lg shadow-md p-4 mb-8">
            <div class="flex items-center justify-between">
                <h3 class="text-lg font-semibold text-gray-700">Selecci√≥n de Nodo</h3>
                <select id="node-selector" onchange="updateNode(this.value)"
                        class="px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500">
                    <option value="all">üìä Todos los Nodos</option>
                    <option value="NVA_P.MONTT___220">‚ö° NVA P.MONTT 220kV (Hist√≥rico)</option>
                    <!-- <option value="PIDPID________110">‚ö° PIDPID 110kV (Hist√≥rico)</option> -->
                    <option value="DALCAHUE______110">‚ö° DALCAHUE 110kV (Hist√≥rico)</option>
                    <option value="PMontt220">üìà Puerto Montt 220kV (Programado)</option>
                </select>
            </div>
        </div>

        <!-- Main Chart -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">
                Evoluci√≥n del CMG - <span id="chart-title">Todos los Nodos</span>
            </h2>
            <div id="main-chart" class="w-full" style="height: 500px;"></div>
        </div>

        <!-- Data Quality Indicators -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <!-- Historical Data Quality -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">
                    üìä Calidad de Datos Hist√≥ricos
                </h3>
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between text-sm mb-1">
                            <span>Cobertura Temporal (√∫ltimas 24h)</span>
                            <span id="hist-coverage-text" class="font-semibold">0h / 24h</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2">
                            <div id="hist-coverage-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                        </div>
                    </div>
                    <div>
                        <div class="flex justify-between text-sm mb-1">
                            <span>Nodos Disponibles</span>
                            <span id="hist-nodes-text" class="font-semibold">0/6</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2">
                            <div id="hist-nodes-bar" class="bg-green-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Programmed Data Availability -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">
                    üîÆ Datos Programados Disponibles
                </h3>
                <div id="prog-status" class="mb-3 text-sm">
                    <!-- Status will be updated by JavaScript -->
                </div>
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between text-sm mb-1">
                            <span>Horas Disponibles</span>
                            <span id="prog-hours-text" class="font-semibold">0h</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2">
                            <div id="prog-hours-bar" class="bg-purple-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                        </div>
                    </div>
                    <div id="prog-dates" class="text-xs text-gray-600 mt-2">
                        <!-- Date range will be updated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentData = null;
        let mlPredictions = null;  // ML predictions from Railway
        let selectedNode = 'all';
        let isRefreshing = false;
        let autoRefreshInterval = null;
        
        // Node colors for multi-line chart
        const nodeColors = {
            'NVA_P.MONTT___220': '#ef4444',  // red
            // 'PIDPID________110': '#3b82f6',  // blue - COMMENTED OUT: Not in use
            'DALCAHUE______110': '#10b981',  // green
            'PMontt220': '#8b5cf6'           // purple
        };

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Initializing CMG Monitor...');

            // Check authentication first
            const session = await requireAuth();
            if (!session) {
                return; // Will redirect to login
            }

            initializeApp();
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            const plotDiv = document.getElementById('main-chart');
            if (plotDiv && plotDiv.data) {
                Plotly.Plots.resize(plotDiv);
            }
        });

        async function initializeApp() {
            try {
                // Stage 1: Initial setup
                updateLoadingStage('Inicializando sistema...', 'Configurando componentes...');
                await sleep(500);
                
                // Stage 2: Fetch data
                updateLoadingStage('Cargando datos...', 'Obteniendo datos del servidor...');
                await fetchAndUpdateData();
                
                // Stage 3: Show main content
                updateLoadingStage('Preparando visualizaci√≥n...', 'Renderizando gr√°ficos...');
                await sleep(300);
                
                // Hide loading, show content
                document.getElementById('loading-container').classList.add('hidden');
                document.getElementById('main-content').classList.remove('hidden');
                
                // Force chart resize after content is visible
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 100);
                
                // Start auto-refresh
                startAutoRefresh();
                
            } catch (error) {
                console.error('Error initializing app:', error);
                updateLoadingStage('Error al cargar', 'Por favor, recarga la p√°gina');
            }
        }

        function updateLoadingStage(stage, detail) {
            document.getElementById('loading-stage').textContent = stage;
            document.getElementById('loading-detail').textContent = detail;
        }

        async function fetchAndUpdateData() {
            try {
                // Fetch historical/programmed data
                const response = await fetchWithTimeout('/api/cmg/current', 30000);

                if (response.success) {
                    currentData = response.data;

                    // Also fetch ML predictions (don't fail if unavailable)
                    try {
                        const mlResponse = await fetchWithTimeout('/api/ml_forecast', 10000);
                        if (mlResponse.success) {
                            mlPredictions = mlResponse;
                            console.log('‚úÖ ML predictions loaded:', mlResponse.predictions_count);
                        }
                    } catch (mlError) {
                        console.warn('‚ö†Ô∏è ML predictions not available:', mlError);
                        mlPredictions = null;
                    }

                    updateUI(currentData);
                } else {
                    throw new Error(response.error || 'Failed to fetch data');
                }
            } catch (error) {
                console.error('Error fetching data:', error);
                // Show error state but don't crash
                updateStatusIndicator(null, null);
            }
        }

        async function fetchWithTimeout(url, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, { signal: controller.signal });
                const data = await response.json();
                return data;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        function updateUI(data) {
            if (!data) return;
            
            // Update status indicator
            updateStatusIndicator(data.status, data);
            
            // Update statistics
            updateStatistics(data);
            
            // Update chart
            updateChart(data);
            
            // Update data quality indicators
            updateQualityIndicators(data);
        }

        function updateStatusIndicator(status, data) {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const lastUpdate = document.getElementById('last-update');
            
            // Remove all status classes
            indicator.className = 'status-indicator';
            
            // Set status based on data freshness
            if (status && status.overall) {
                switch(status.overall.status) {
                    case 'ready':
                    case 'operational':
                        indicator.classList.add('status-live');
                        statusText.textContent = 'En vivo';
                        break;
                    case 'recent':
                        indicator.classList.add('status-recent');
                        statusText.textContent = 'Datos recientes';
                        break;
                    case 'stale':
                        indicator.classList.add('status-stale');
                        statusText.textContent = 'Datos antiguos';
                        break;
                    case 'updating':
                        indicator.classList.add('status-updating');
                        statusText.textContent = 'Actualizando...';
                        break;
                    default:
                        indicator.classList.add('status-updating');
                        statusText.textContent = 'Inicializando...';
                }
            }
            
            // Update last update time
            if (data && data.historical && data.historical.last_updated) {
                const updateTime = new Date(data.historical.last_updated);
                lastUpdate.textContent = `√öltima actualizaci√≥n: ${formatTime(updateTime)}`;
            }
        }

        function updateStatistics(data) {
            if (!data || !data.historical || !data.historical.data) return;
            
            const historicalData = data.historical.data;
            
            if (historicalData.length > 0) {
                // Filter by selected node
                const filteredData = selectedNode === 'all' 
                    ? historicalData 
                    : historicalData.filter(d => d.node === selectedNode);
                
                if (filteredData.length > 0) {
                    // Current CMG - use cmg_usd or cmg_real
                    // API returns data sorted by datetime DESC (newest first), so take first element
                    const latest = filteredData[0];
                    const latestValue = latest.cmg_usd !== undefined ? latest.cmg_usd : (latest.cmg_actual || 0);
                    document.getElementById('current-cmg').textContent = `$${latestValue.toFixed(2)}`;
                    document.getElementById('current-time').textContent = latest.datetime;
                    
                    // Average - handle both field names
                    const values = filteredData.map(d => {
                        if (d.cmg_usd !== undefined) return d.cmg_usd;
                        if (d.cmg_actual !== undefined) return d.cmg_actual;
                        return 0;
                    }).filter(v => v > 0);
                    
                    if (values.length > 0) {
                        const average = values.reduce((a, b) => a + b, 0) / values.length;
                        document.getElementById('average-cmg').textContent = `$${average.toFixed(2)}`;
                        
                        // Maximum
                        const max = Math.max(...values);
                        const maxRecord = filteredData.find(d => {
                            const val = d.cmg_usd !== undefined ? d.cmg_usd : (d.cmg_actual || 0);
                            return val === max;
                        });
                        document.getElementById('max-cmg').textContent = `$${max.toFixed(2)}`;
                        document.getElementById('max-time').textContent = maxRecord ? maxRecord.datetime : '--';
                    } else {
                        // No valid values - use all values including zeros
                        const allValues = filteredData.map(d => {
                            if (d.cmg_usd !== undefined) return d.cmg_usd;
                            if (d.cmg_actual !== undefined) return d.cmg_actual;
                            return 0;
                        });
                        
                        if (allValues.length > 0) {
                            const average = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                            document.getElementById('average-cmg').textContent = `$${average.toFixed(2)}`;
                            document.getElementById('max-cmg').textContent = `$${Math.max(...allValues).toFixed(2)}`;
                            document.getElementById('max-time').textContent = '--';
                        } else {
                            document.getElementById('average-cmg').textContent = '$0.00';
                            document.getElementById('max-cmg').textContent = '$0.00';
                            document.getElementById('max-time').textContent = '--';
                        }
                    }
                }
            }
            
            // Coverage
            const coverage = data.historical.coverage || 
                           ((data.historical.data.length / (24 * 3)) * 100);
            document.getElementById('coverage').textContent = `${coverage.toFixed(0)}%`;
            
            // Nodes available
            const uniqueNodes = new Set(historicalData.map(d => d.node));
            document.getElementById('nodes-available').textContent = `${uniqueNodes.size} de 3 nodos`;
        }

        function updateChart(data) {
            if (!data) return;
            
            const plotDiv = document.getElementById('main-chart');
            const traces = [];
            
            if (selectedNode === 'all') {
                // Show all nodes with different colors
                const nodeGroups = {};
                
                // Group historical data by node
                if (data.historical && data.historical.data) {
                    data.historical.data.forEach(record => {
                        const node = record.node;
                        if (!nodeGroups[node]) {
                            nodeGroups[node] = {
                                historical: [],
                                programmed: []
                            };
                        }
                        nodeGroups[node].historical.push(record);
                    });
                }
                
                // Group programmed data by node
                if (data.programmed && data.programmed.data) {
                    data.programmed.data.forEach(record => {
                        const node = record.node;
                        if (!nodeGroups[node]) {
                            nodeGroups[node] = {
                                historical: [],
                                programmed: []
                            };
                        }
                        nodeGroups[node].programmed.push(record);
                    });
                }
                
                // Create traces for each node (excluding PIDPID)
                Object.keys(nodeGroups).forEach(node => {
                    // Skip PIDPID node - not in use
                    if (node === 'PIDPID________110') return;

                    const nodeData = nodeGroups[node];
                    const color = nodeColors[node] || '#6b7280';

                    // Historical trace for this node
                    if (nodeData.historical.length > 0) {
                        traces.push({
                            x: nodeData.historical.map(d => d.datetime),
                            y: nodeData.historical.map(d => d.cmg_usd !== undefined ? d.cmg_usd : (d.cmg_actual || 0)),
                            name: `${node} (Hist√≥rico)`,
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: color, width: 2 },
                            marker: { size: 4 }
                        });
                    }
                    
                    // Programmed trace for this node
                    if (nodeData.programmed.length > 0) {
                        traces.push({
                            x: nodeData.programmed.map(d => d.datetime),
                            y: nodeData.programmed.map(d => d.cmg_programmed),
                            name: `${node} (Programado)`,
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: color, width: 2, dash: 'dot' },
                            marker: { size: 4 }
                        });
                    }
                });
            } else {
                // Show single node
                // Historical trace
                if (data.historical && data.historical.data) {
                    const filteredHistorical = data.historical.data.filter(d => d.node === selectedNode);
                    if (filteredHistorical.length > 0) {
                        traces.push({
                            x: filteredHistorical.map(d => d.datetime),
                            y: filteredHistorical.map(d => d.cmg_usd !== undefined ? d.cmg_usd : (d.cmg_actual || 0)),
                            name: 'CMG Hist√≥rico',
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: nodeColors[selectedNode] || '#3b82f6', width: 3 },
                            marker: { size: 6 }
                        });
                    }
                }
                
                // Programmed trace
                if (data.programmed && data.programmed.data) {
                    const filteredProgrammed = data.programmed.data.filter(d => d.node === selectedNode);
                    if (filteredProgrammed.length > 0) {
                        traces.push({
                            x: filteredProgrammed.map(d => d.datetime),
                            y: filteredProgrammed.map(d => d.cmg_programmed),
                            name: 'CMG Programado',
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: nodeColors[selectedNode] || '#10b981', width: 3, dash: 'dot' },
                            marker: { size: 6 }
                        });
                    }
                }
            }

            // Add ML Predictions trace (always shown for all nodes view)
            if (mlPredictions && mlPredictions.predictions && selectedNode === 'all') {
                const mlData = mlPredictions.predictions;

                // Convert UTC datetimes to Santiago time (UTC-3)
                // ML predictions come as "2025-11-18T15:00:00+00:00" (UTC)
                // Historical/Programmed come as "2025-11-18 12:00:00" (local, no timezone)
                // We need to convert ML times to local format for consistency
                const convertToSantiagoTime = (utcDatetimeStr) => {
                    const date = new Date(utcDatetimeStr);
                    // Format as "YYYY-MM-DD HH:MM:SS" in local timezone (Santiago)
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    const seconds = String(date.getSeconds()).padStart(2, '0');
                    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                };

                // ML Prediction line (blue, dotted)
                traces.push({
                    x: mlData.map(d => convertToSantiagoTime(d.datetime)),
                    y: mlData.map(d => d.predicted_cmg || d.cmg_predicted || 0),
                    name: 'ü§ñ Predicci√≥n ML',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: {
                        color: '#3b82f6',  // Blue
                        width: 3,
                        dash: 'dot'
                    },
                    marker: {
                        size: 6,
                        color: '#3b82f6',  // Blue for all points
                        symbol: 'circle'
                    },
                    hovertemplate:
                        '<b>ML Prediction</b><br>' +
                        'Fecha: %{x}<br>' +
                        'CMG: $%{y:.2f}<br>' +
                        '<extra></extra>'
                });
            }

            // Update chart title
            document.getElementById('chart-title').textContent =
                selectedNode === 'all' ? 'Todos los Nodos' : selectedNode;

            const layout = {
                xaxis: {
                    title: 'Fecha y Hora',
                    type: 'date',
                    tickformat: '%H:%M\n%d %b'
                },
                yaxis: {
                    title: 'CMG (USD/MWh)',
                    rangemode: 'tozero'
                },
                showlegend: true,
                legend: {
                    x: 0,
                    y: 1,
                    bgcolor: 'rgba(255,255,255,0.8)'
                },
                hovermode: 'x unified',
                margin: { t: 20, r: 20, b: 60, l: 60 }
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };
            
            // Force proper width on initial render
            plotDiv.style.width = '100%';
            
            Plotly.newPlot(plotDiv, traces, layout, config).then(() => {
                // Force resize after initial render to ensure proper width
                window.dispatchEvent(new Event('resize'));
            });
        }

        function updateQualityIndicators(data) {
            // Historical data quality
            if (data.historical) {
                const totalHours = 24;  // Last 24 hours is our target
                const uniqueHours = new Set();
                const uniqueNodes = new Set();
                
                if (data.historical.data) {
                    data.historical.data.forEach(record => {
                        uniqueHours.add(record.hour);
                        uniqueNodes.add(record.node);
                    });
                }
                
                const hoursAvailable = uniqueHours.size;
                const coverage = (hoursAvailable / totalHours) * 100;
                
                // Show actual hours out of 24h target
                document.getElementById('hist-coverage-text').textContent = 
                    `${hoursAvailable}h / 24h (${coverage.toFixed(0)}%)`;
                document.getElementById('hist-coverage-bar').style.width = `${coverage}%`;
                
                const nodes = uniqueNodes.size;
                document.getElementById('hist-nodes-text').textContent = `${nodes}/3`;
                document.getElementById('hist-nodes-bar').style.width = `${(nodes/3)*100}%`;
            }
            
            // Programmed data quality - show ACTUAL data like optimizer.html
            if (data.programmed && data.programmed.data && Array.isArray(data.programmed.data)) {
                const sortedData = data.programmed.data.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));
                
                if (sortedData.length > 0) {
                    const hoursAvailable = sortedData.length;
                    const startDate = new Date(sortedData[0].datetime);
                    const endDate = new Date(sortedData[sortedData.length - 1].datetime);
                    
                    // Format dates for display
                    const formatDate = (date) => {
                        return date.toLocaleDateString('es-CL', {
                            day: 'numeric',
                            month: 'short',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    };
                    
                    // Update status with green checkmark like optimizer
                    document.getElementById('prog-status').innerHTML = 
                        `<strong style="color: #059669;">‚úì ${hoursAvailable} horas disponibles</strong>`;
                    
                    // Update hours display - 48h is our target (100%)
                    document.getElementById('prog-hours-text').textContent = `${hoursAvailable}h / 48h`;
                    const hoursPercentage = Math.min((hoursAvailable / 48) * 100, 100);
                    document.getElementById('prog-hours-bar').style.width = `${hoursPercentage}%`;
                    
                    // Update date range
                    document.getElementById('prog-dates').innerHTML = 
                        `<strong>Desde:</strong> ${formatDate(startDate)}<br>` +
                        `<strong>Hasta:</strong> ${formatDate(endDate)}`;
                } else {
                    // No data
                    document.getElementById('prog-status').innerHTML = 
                        '<span style="color: #dc2626;">‚ö†Ô∏è Sin datos disponibles</span>';
                    document.getElementById('prog-hours-text').textContent = '0h / 48h';
                    document.getElementById('prog-hours-bar').style.width = '0%';
                    document.getElementById('prog-dates').innerHTML = '';
                }
            } else {
                // No data available or error
                document.getElementById('prog-status').innerHTML = 
                    '<span style="color: #dc2626;">‚ö†Ô∏è No se pudo verificar la disponibilidad</span>';
                document.getElementById('prog-hours-text').textContent = '0h / 48h';
                document.getElementById('prog-hours-bar').style.width = '0%';
                document.getElementById('prog-dates').innerHTML = '';
            }
        }

        function updateNode(node) {
            selectedNode = node;
            if (currentData) {
                updateStatistics(currentData);
                updateChart(currentData);
            }
        }

        async function manualRefresh() {
            if (isRefreshing) return;
            
            isRefreshing = true;
            const btn = document.getElementById('refresh-btn');
            const btnText = document.getElementById('refresh-text');
            const icon = document.getElementById('refresh-icon');
            
            // Update UI
            btn.disabled = true;
            btnText.textContent = 'Actualizando...';
            icon.classList.add('animate-spin');
            
            try {
                await fetchAndUpdateData();
            } finally {
                // Reset UI
                btn.disabled = false;
                btnText.textContent = 'Actualizar';
                icon.classList.remove('animate-spin');
                isRefreshing = false;
            }
        }

        function startAutoRefresh() {
            // Auto refresh every 5 minutes
            autoRefreshInterval = setInterval(fetchAndUpdateData, 5 * 60 * 1000);
        }

        function formatTime(date) {
            return date.toLocaleString('es-CL', {
                hour: '2-digit',
                minute: '2-digit',
                day: '2-digit',
                month: 'short'
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>