<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparaci√≥n de Pron√≥sticos - CMG Monitor</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Plotly for charts -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <!-- Supabase Client -->
    <script src="/js/supabase-client.js"></script>

    <style>
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-blue-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-lg">
        <div class="container mx-auto px-4 py-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">
                        üîÆ Comparaci√≥n de Pron√≥sticos
                    </h1>
                    <p class="text-gray-600 mt-2">
                        Visualiza pron√≥sticos hist√≥ricos y compara con valores reales
                    </p>
                </div>
                <div class="flex gap-2">
                    <a href="index.html"
                       class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                  d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                        </svg>
                        <span>Inicio</span>
                    </a>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container mx-auto px-4 py-8">

        <!-- Date/Hour Selector -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">üìÖ Seleccionar Pron√≥stico</h2>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Fecha</label>
                    <input type="date" id="date-selector"
                           class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                           onchange="onDateSelected()">
                    <p id="date-availability" class="text-xs text-gray-500 mt-1"></p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Hora</label>
                    <select id="hour-selector" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="">Seleccionar primero una fecha</option>
                    </select>
                </div>
                <div class="flex items-end">
                    <button id="load-forecast-btn" onclick="loadForecast()"
                            class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg transition-colors font-semibold">
                        Cargar Pron√≥stico
                    </button>
                </div>
            </div>

            <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
                <h3 class="font-semibold text-blue-900 mb-2">‚ÑπÔ∏è C√≥mo Usar</h3>
                <p class="text-sm text-blue-800 mb-2">
                    Selecciona una fecha y hora espec√≠fica para ver la matriz completa de pron√≥sticos (t+1 a t+24).
                    Se muestran las <strong>24 horas de predicciones</strong> que se hicieron en ese momento.
                </p>
                <p class="text-sm text-blue-800">
                    <strong>Ejemplo:</strong> Si seleccionas las 14:00 del Nov 24, ver√°s predicciones para Nov 24 15:00 hasta Nov 25 14:00.
                </p>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loading-container" class="hidden bg-white rounded-xl shadow-lg p-8">
            <div class="flex flex-col items-center justify-center">
                <div class="loading-spinner mb-4"></div>
                <h2 class="text-xl font-semibold text-gray-700">
                    Cargando pron√≥sticos...
                </h2>
            </div>
        </div>

        <!-- Forecast Results -->
        <div id="results-container" class="hidden">
            <!-- Forecast Info -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">üìä Pron√≥stico Seleccionado</h2>
                <div id="forecast-info" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Will be populated -->
                </div>
            </div>

            <!-- Comparison Chart -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">üìà Comparaci√≥n Visual</h2>
                <div id="comparison-chart" style="height: 500px;"></div>
            </div>

            <!-- Unified Comparison Table -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">üìä Comparaci√≥n Detallada</h3>
                <div class="overflow-x-auto">
                    <table id="comparison-table" class="w-full text-sm">
                        <!-- Will be populated -->
                    </table>
                </div>
            </div>
        </div>

        <!-- Error State -->
        <div id="error-container" class="hidden bg-red-50 border border-red-200 rounded-lg p-6">
            <h3 class="text-red-900 font-bold mb-2">‚ùå Error</h3>
            <p id="error-message" class="text-red-800"></p>
        </div>

    </div>

    <script>
        let historicalData = null;

        // Load historical data on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await loadHistoricalData();
        });

        async function loadHistoricalData(date = null, hour = null) {
            try {
                console.log('Loading historical comparison data from backend...');

                // Build API URL based on mode
                let apiUrl = '/api/historical_comparison';
                if (date && hour !== null) {
                    // Detail Mode: fetch specific date/hour
                    apiUrl += `?date=${date}&hour=${hour}`;
                    console.log(`Detail Mode: Fetching ${date} ${hour}:00`);
                } else {
                    // Summary Mode: fetch available hours
                    console.log('Summary Mode: Fetching available hours');
                }

                const response = await fetch(apiUrl);

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const apiData = await response.json();

                if (!apiData.success) {
                    throw new Error(apiData.message || 'Failed to load data');
                }

                console.log('API Response:', apiData);

                // Handle based on mode
                if (apiData.mode === 'summary') {
                    // Summary Mode: populate date/hour selector
                    populateDateSelectorFromAvailableHours(apiData.data.available_hours);
                    console.log(`Loaded ${apiData.metadata.total_hours} available hours`);
                } else if (apiData.mode === 'detail') {
                    // Detail Mode: transform and display forecast data
                    const mlData = transformMLPredictionsFromAPI(apiData.data.ml_predictions || {});
                    const progData = transformCMGProgramadoFromAPI(apiData.data.cmg_programado_by_forecast || {});
                    const onlineData = transformCMGOnlineFromAPI(apiData.data.cmg_online || []);

                    // Merge the 3 data sources into unified structure
                    historicalData = mergeGistData(mlData, progData, onlineData);

                    console.log('Merged historical data:', historicalData);
                    // Data is now ready for rendering by loadForecast()
                }
            } catch (error) {
                console.error('Error loading historical data:', error);
                showError('No se pudo cargar los datos hist√≥ricos. Por favor, intenta m√°s tarde.');
            }
        }

        // ========================================
        // TIMEZONE HELPERS (Santiago/Chile = UTC-3)
        // ========================================

        /**
         * Extract date in Santiago timezone (YYYY-MM-DD format)
         * @param {string} utcDatetimeStr - UTC datetime string (ISO format)
         * @returns {string} Date in Santiago timezone (YYYY-MM-DD)
         */
        function getChileDate(utcDatetimeStr) {
            const date = new Date(utcDatetimeStr);
            // Format as YYYY-MM-DD in Chile timezone
            // en-CA locale gives YYYY-MM-DD format
            return date.toLocaleString('en-CA', {
                timeZone: 'America/Santiago',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
        }

        /**
         * Extract hour in Santiago timezone (0-23)
         * @param {string} utcDatetimeStr - UTC datetime string (ISO format)
         * @returns {number} Hour in Santiago timezone (0-23)
         */
        function getChileHour(utcDatetimeStr) {
            const date = new Date(utcDatetimeStr);
            // Get hour in Chile timezone
            const hourStr = date.toLocaleString('en-US', {
                timeZone: 'America/Santiago',
                hour12: false,
                hour: '2-digit'
            });
            return parseInt(hourStr);
        }

        function transformMLPredictionsFromAPI(mlByForecast) {
            const daily_data = {};

            // ML predictions are NOW grouped by (forecast_date, forecast_hour) from backend
            // Keys are already in Santiago timezone format: "YYYY-MM-DD HH:00:00"
            // No timezone conversion needed!
            for (const [forecastTime, predictions] of Object.entries(mlByForecast)) {
                // Parse Santiago time key (format: "YYYY-MM-DD HH:00:00")
                const [datePart, timePart] = forecastTime.split(' ');
                const dateKey = datePart;  // "YYYY-MM-DD"
                const hour = parseInt(timePart.split(':')[0]);  // Extract hour as integer

                if (!daily_data[dateKey]) {
                    daily_data[dateKey] = {
                        ml_forecasts: {}
                    };
                }

                // Store predictions under the hour when the forecast was made
                daily_data[dateKey].ml_forecasts[hour] = {
                    forecast_time: forecastTime,
                    model_version: predictions[0]?.model_version || 'v2.0',
                    predictions: predictions.map(pred => {
                        // Convert target_datetime from UTC to Santiago timezone
                        const targetUTC = new Date(pred.target_datetime);
                        const targetSantiago = targetUTC.toLocaleString('sv-SE', {
                            timeZone: 'America/Santiago',
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            hour12: false
                        }).replace(' ', 'T');

                        return {
                            horizon: pred.horizon,
                            target_datetime: targetSantiago,  // Now in Santiago time
                            cmg: pred.predicted_cmg ?? pred.cmg_predicted,  // Use ?? to handle 0 values correctly
                            prob_zero: pred.prob_zero ?? 0,
                            threshold: pred.threshold ?? 0.5
                        };
                    })
                };
            }

            return { daily_data };
        }

        function transformCMGProgramadoFromAPI(programadoByForecast) {
            const daily_data = {};

            // Input is NOW grouped by (forecast_date, forecast_hour) from the API
            // Keys are already in Santiago timezone format: "YYYY-MM-DD HH:00:00"
            for (const [forecastTime, predictions] of Object.entries(programadoByForecast)) {
                // Parse Santiago time key (format: "YYYY-MM-DD HH:00:00")
                const [datePart, timePart] = forecastTime.split(' ');
                const dateKey = datePart;  // "YYYY-MM-DD"
                const hour = parseInt(timePart.split(':')[0]);  // Extract hour as integer

                if (!daily_data[dateKey]) {
                    daily_data[dateKey] = {
                        cmg_programado_forecasts: {}
                    };
                }

                // Group predictions by node
                const forecasts = {};
                predictions.forEach(pred => {
                    const node = pred.node;
                    if (!forecasts[node]) {
                        forecasts[node] = [];
                    }

                    // Convert target_datetime from UTC to Santiago timezone
                    const targetUTC = new Date(pred.target_datetime);
                    const targetSantiago = targetUTC.toLocaleString('sv-SE', {
                        timeZone: 'America/Santiago',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    }).replace(' ', 'T');

                    forecasts[node].push({
                        datetime: targetSantiago,  // Now in Santiago time
                        cmg: pred.cmg_programmed  // Direct assignment works for 0 values
                    });
                });

                // Sort forecasts by datetime (target datetime)
                Object.values(forecasts).forEach(nodeForecasts => {
                    nodeForecasts.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));
                });

                // Store forecast snapshot under the hour when it was made
                daily_data[dateKey].cmg_programado_forecasts[hour] = {
                    forecast_time: forecastTime,
                    forecasts: forecasts
                };
            }

            return { daily_data };
        }

        function transformCMGOnlineFromAPI(onlineArray) {
            const daily_data = {};

            onlineArray.forEach(record => {
                // API returns datetime in format: "YYYY-MM-DD HH:00:00" (already Santiago timezone)
                // Parse it directly without timezone conversion
                const [datePart, timePart] = record.datetime.split(' ');
                const dateKey = datePart;  // "YYYY-MM-DD"
                const hour = parseInt(timePart.split(':')[0]);  // Extract hour as integer

                if (!daily_data[dateKey]) {
                    daily_data[dateKey] = {
                        hours: [],
                        cmg_online: {}
                    };
                }

                if (!daily_data[dateKey].cmg_online[record.node]) {
                    daily_data[dateKey].cmg_online[record.node] = {
                        cmg_usd: Array(24).fill(null)
                    };
                }

                daily_data[dateKey].cmg_online[record.node].cmg_usd[hour] = record.cmg_actual;

                if (!daily_data[dateKey].hours.includes(hour)) {
                    daily_data[dateKey].hours.push(hour);
                }
            });

            // Sort hours for each day
            for (const dateKey in daily_data) {
                daily_data[dateKey].hours.sort((a, b) => a - b);
            }

            return { daily_data };
        }

        function transformMLPredictions(records) {
            const daily_data = {};

            records.forEach(record => {
                const forecastTime = new Date(record.forecast_datetime);
                const date = forecastTime.toISOString().split('T')[0];
                const hour = forecastTime.getUTCHours();

                if (!daily_data[date]) {
                    daily_data[date] = { ml_forecasts: {} };
                }
                if (!daily_data[date].ml_forecasts[hour]) {
                    daily_data[date].ml_forecasts[hour] = {
                        forecast_time: record.forecast_datetime,
                        model_version: record.model_version || 'v2.0',
                        predictions: []
                    };
                }

                daily_data[date].ml_forecasts[hour].predictions.push({
                    horizon: record.horizon,
                    target_datetime: record.target_datetime,
                    cmg: record.cmg_predicted,
                    prob_zero: record.prob_zero || 0,
                    threshold: record.threshold || 0.5
                });
            });

            // Sort predictions by horizon
            Object.values(daily_data).forEach(day => {
                Object.values(day.ml_forecasts).forEach(forecast => {
                    forecast.predictions.sort((a, b) => a.horizon - b.horizon);
                });
            });

            return {
                metadata: {
                    last_update: new Date().toISOString(),
                    total_forecasts: records.length,
                    source: 'supabase'
                },
                daily_data
            };
        }

        function transformCMGProgramado(records) {
            const daily_data = {};

            // Group by fetched_at (the forecast snapshot time)
            const snapshots = {};
            records.forEach(record => {
                const fetchedAt = record.fetched_at || record.created_at;
                if (!snapshots[fetchedAt]) {
                    snapshots[fetchedAt] = [];
                }
                snapshots[fetchedAt].push(record);
            });

            // Transform each snapshot
            Object.entries(snapshots).forEach(([fetchedAt, snapshotRecords]) => {
                const fetchedTime = new Date(fetchedAt);
                const date = fetchedTime.toISOString().split('T')[0];
                const hour = fetchedTime.getUTCHours();

                if (!daily_data[date]) {
                    daily_data[date] = { cmg_programado_forecasts: {} };
                }

                const forecasts = {};
                snapshotRecords.forEach(record => {
                    const node = record.node || 'PMontt220';
                    if (!forecasts[node]) {
                        forecasts[node] = [];
                    }
                    forecasts[node].push({
                        datetime: record.datetime,
                        cmg: record.cmg_programmed
                    });
                });

                // Sort forecasts by datetime
                Object.values(forecasts).forEach(nodeForecasts => {
                    nodeForecasts.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));
                });

                daily_data[date].cmg_programado_forecasts[hour] = {
                    fetched_at: fetchedAt,
                    forecasts
                };
            });

            return {
                metadata: {
                    last_update: new Date().toISOString(),
                    total_records: records.length,
                    source: 'supabase'
                },
                daily_data
            };
        }

        function transformCMGOnline(records) {
            const daily_data = {};

            records.forEach(record => {
                const date = record.date;
                const hour = record.hour;
                const node = record.node;

                if (!daily_data[date]) {
                    daily_data[date] = {
                        hours: [],
                        cmg_online: {}
                    };
                }

                if (!daily_data[date].cmg_online[node]) {
                    daily_data[date].cmg_online[node] = {
                        cmg_usd: new Array(24).fill(null)
                    };
                }

                daily_data[date].cmg_online[node].cmg_usd[hour] = record.cmg_usd;

                if (!daily_data[date].hours.includes(hour)) {
                    daily_data[date].hours.push(hour);
                    daily_data[date].hours.sort((a, b) => a - b);
                }
            });

            return {
                metadata: {
                    last_update: new Date().toISOString(),
                    total_records: records.length,
                    source: 'supabase'
                },
                daily_data
            };
        }

        function mergeGistData(mlData, progData, onlineData) {
            // Start with CMG Online as base (30-day window)
            const merged = {
                metadata: {
                    ...onlineData.metadata,
                    last_update: new Date().toISOString(),
                    structure_version: '3.0'
                },
                daily_data: {}
            };

            // Merge CMG Online data (actual values)
            if (onlineData.daily_data) {
                for (const [date, data] of Object.entries(onlineData.daily_data)) {
                    merged.daily_data[date] = {
                        hours: data.hours || [],
                        cmg_online: data.cmg_online || {},
                        ml_forecasts: {},
                        cmg_programado_forecasts: {}
                    };
                }
            }

            // Merge ML predictions (7-day window)
            if (mlData.daily_data) {
                for (const [date, data] of Object.entries(mlData.daily_data)) {
                    if (!merged.daily_data[date]) {
                        merged.daily_data[date] = {
                            hours: [],
                            cmg_online: {},
                            ml_forecasts: {},
                            cmg_programado_forecasts: {}
                        };
                    }
                    merged.daily_data[date].ml_forecasts = data.ml_forecasts || {};
                }
            }

            // Merge CMG Programado forecasts (7-day window)
            if (progData.daily_data) {
                for (const [date, data] of Object.entries(progData.daily_data)) {
                    if (!merged.daily_data[date]) {
                        merged.daily_data[date] = {
                            hours: [],
                            cmg_online: {},
                            ml_forecasts: {},
                            cmg_programado_forecasts: {}
                        };
                    }
                    merged.daily_data[date].cmg_programado_forecasts = data.cmg_programado_forecasts || {};
                }
            }

            return merged;
        }

        // Store available hours globally for date picker
        let availableHoursByDate = {};

        // NEW: Populate selectors from Summary Mode API response
        function populateDateSelectorFromAvailableHours(availableHours) {
            const dateSelector = document.getElementById('date-selector');
            const hourSelector = document.getElementById('hour-selector');
            const dateAvailability = document.getElementById('date-availability');

            if (!availableHours || availableHours.length === 0) {
                dateAvailability.textContent = 'No hay datos disponibles';
                dateAvailability.className = 'text-xs text-red-500 mt-1';
                return;
            }

            // Group hours by date
            availableHoursByDate = {};
            availableHours.forEach(item => {
                const date = item.date;
                if (!availableHoursByDate[date]) {
                    availableHoursByDate[date] = [];
                }
                availableHoursByDate[date].push({
                    hour: item.hour,
                    has_ml: item.has_ml,
                    has_programado: item.has_programado
                });
            });

            // Get dates sorted
            const dates = Object.keys(availableHoursByDate).sort();

            if (dates.length > 0) {
                // Set min/max for date picker
                dateSelector.min = dates[0];
                dateSelector.max = dates[dates.length - 1];

                // Default to most recent date
                dateSelector.value = dates[dates.length - 1];

                // Show availability info
                dateAvailability.textContent = `Datos disponibles: ${dates[0]} a ${dates[dates.length - 1]}`;
                dateAvailability.className = 'text-xs text-green-600 mt-1';

                // Trigger date selection to populate hours
                onDateSelected();
            }
        }

        // Handle date picker change
        function onDateSelected() {
            const dateSelector = document.getElementById('date-selector');
            const hourSelector = document.getElementById('hour-selector');
            const dateAvailability = document.getElementById('date-availability');
            const selectedDate = dateSelector.value;

            if (!selectedDate) {
                hourSelector.innerHTML = '<option value="">Seleccionar primero una fecha</option>';
                return;
            }

            const hoursData = availableHoursByDate[selectedDate] || [];

            if (hoursData.length === 0) {
                hourSelector.innerHTML = '<option value="">No hay datos para esta fecha</option>';
                dateAvailability.textContent = `‚ö†Ô∏è Sin datos para ${selectedDate}`;
                dateAvailability.className = 'text-xs text-yellow-600 mt-1';
                return;
            }

            // Sort hours ascending
            hoursData.sort((a, b) => a.hour - b.hour);

            // Calculate remaining hours for each option
            hourSelector.innerHTML = '<option value="">Seleccionar hora</option>' +
                hoursData.map(item => {
                    const mlIcon = item.has_ml ? '‚úÖ' : '‚è≥';
                    const progIcon = item.has_programado ? '‚úÖ' : '‚è≥';
                    const remainingHours = 23 - item.hour;
                    return `<option value="${item.hour}">${item.hour.toString().padStart(2, '0')}:00 ‚Üí ${remainingHours}h (ML:${mlIcon} Prog:${progIcon})</option>`;
                }).join('');

            // Update availability message
            dateAvailability.textContent = `‚úì ${hoursData.length} horas disponibles para ${selectedDate}`;
            dateAvailability.className = 'text-xs text-green-600 mt-1';
        }

        function populateDateSelector() {
            const dateSelector = document.getElementById('date-selector');
            const hourSelector = document.getElementById('hour-selector');

            if (!historicalData || !historicalData.daily_data) {
                dateSelector.innerHTML = '<option value="">No hay datos disponibles</option>';
                return;
            }

            // Get available dates with forecast matrices OR any CMG data
            // This makes it backward compatible with v2.0 structure
            const datesWithForecasts = Object.keys(historicalData.daily_data)
                .filter(date => {
                    const day = historicalData.daily_data[date];
                    // v3.0: Has new forecast matrices
                    const hasV3Forecasts = day.ml_forecasts || day.cmg_programado_forecasts;
                    // v2.0: Has any CMG data
                    const hasV2Data = day.cmg_online || day.cmg_programado;
                    return hasV3Forecasts || hasV2Data;
                })
                .sort()
                .reverse();

            if (datesWithForecasts.length === 0) {
                dateSelector.innerHTML = '<option value="">No hay pron√≥sticos disponibles</option>';
                return;
            }

            dateSelector.innerHTML = '<option value="">Seleccionar fecha</option>' +
                datesWithForecasts.map(date =>
                    `<option value="${date}">${date}</option>`
                ).join('');

            // Handle date selection
            dateSelector.addEventListener('change', function() {
                const selectedDate = this.value;
                if (!selectedDate) {
                    hourSelector.innerHTML = '<option value="">Seleccionar primero una fecha</option>';
                    return;
                }

                const dayData = historicalData.daily_data[selectedDate];
                const availableHours = new Set();

                // v3.0: Get hours from forecast matrices
                if (dayData.ml_forecasts) {
                    Object.keys(dayData.ml_forecasts).forEach(h => availableHours.add(parseInt(h)));
                }
                if (dayData.cmg_programado_forecasts) {
                    Object.keys(dayData.cmg_programado_forecasts).forEach(h => availableHours.add(parseInt(h)));
                }

                // v2.0: If no forecast matrices, show all hours from CMG Online
                if (availableHours.size === 0 && dayData.cmg_online) {
                    // Add hours that have data in any node
                    Object.values(dayData.cmg_online).forEach(nodeData => {
                        if (nodeData.cmg_usd) {
                            nodeData.cmg_usd.forEach((val, idx) => {
                                if (val !== null) availableHours.add(idx);
                            });
                        }
                    });
                }

                // If still no hours, show message
                if (availableHours.size === 0) {
                    hourSelector.innerHTML = '<option value="">No hay datos para esta fecha</option>';
                    return;
                }

                const hours = Array.from(availableHours).sort((a, b) => a - b);

                hourSelector.innerHTML = '<option value="">Seleccionar hora</option>' +
                    hours.map(hour =>
                        `<option value="${hour}">${hour.toString().padStart(2, '0')}:00</option>`
                    ).join('');
            });
        }

        async function loadForecast() {
            const date = document.getElementById('date-selector').value;
            const hour = document.getElementById('hour-selector').value;

            if (!date || hour === '') {
                showError('Por favor, selecciona una fecha y hora');
                return;
            }

            // Show loading
            document.getElementById('loading-container').classList.remove('hidden');
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('error-container').classList.add('hidden');

            try {
                // Fetch Detail Mode data from API
                console.log(`Fetching detail data for ${date} ${hour}:00`);
                await loadHistoricalData(date, hour);

                // Data is now loaded in historicalData by loadHistoricalData()
                if (!historicalData || !historicalData.daily_data || !historicalData.daily_data[date]) {
                    throw new Error('No se pudieron cargar los datos para esta fecha y hora');
                }

                const dayData = historicalData.daily_data[date];
                const mlForecast = dayData.ml_forecasts ? dayData.ml_forecasts[hour] : null;
                const progForecast = dayData.cmg_programado_forecasts ? dayData.cmg_programado_forecasts[hour] : null;
                const actualData = dayData.cmg_online || {};

                // Render forecast info
                renderForecastInfo(date, hour, mlForecast, progForecast);

                // Render comparison chart
                renderComparisonChart(date, hour, mlForecast, progForecast, actualData);

                // Render unified comparison table
                renderComparisonTable(date, hour, mlForecast, progForecast, actualData);

                // Hide loading, show results
                document.getElementById('loading-container').classList.add('hidden');
                document.getElementById('results-container').classList.remove('hidden');

            } catch (error) {
                console.error('Error loading forecast:', error);
                showError('Error al cargar el pron√≥stico: ' + error.message);
                document.getElementById('loading-container').classList.add('hidden');
            }
        }

        function renderForecastInfo(date, hour, mlForecast, progForecast) {
            const container = document.getElementById('forecast-info');

            const hourStr = hour.toString().padStart(2, '0');

            container.innerHTML = `
                <div>
                    <h3 class="text-sm font-medium text-gray-500 mb-1">Fecha y Hora</h3>
                    <p class="text-xl font-bold text-blue-600">${date} ${hourStr}:00</p>
                </div>
                <div>
                    <h3 class="text-sm font-medium text-gray-500 mb-1">Predicciones ML</h3>
                    <p class="text-xl font-bold ${mlForecast ? 'text-green-600' : 'text-yellow-600'}">
                        ${mlForecast ? `‚úÖ ${mlForecast.predictions.length} pron√≥sticos` : '‚è≥ Pendiente'}
                    </p>
                    ${!mlForecast ? '<p class="text-xs text-yellow-700 mt-1">Se guardar√° en el pr√≥ximo ciclo horario</p>' : ''}
                </div>
                <div>
                    <h3 class="text-sm font-medium text-gray-500 mb-1">CMG Programado</h3>
                    <p class="text-xl font-bold ${progForecast ? 'text-purple-600' : 'text-yellow-600'}">
                        ${progForecast ? `‚úÖ Disponible` : '‚è≥ Pendiente'}
                    </p>
                    ${!progForecast ? '<p class="text-xs text-yellow-700 mt-1">Se guardar√° en el pr√≥ximo ciclo horario</p>' : ''}
                </div>
            `;
        }

        function renderComparisonChart(date, hour, mlForecast, progForecast, actualData) {
            const traces = [];
            const forecastDate = date;
            const forecastHour = parseInt(hour);

            // Show FULL 24-hour forecast window (t+1 to t+24)
            // This spans from forecast hour+1 to the same hour next day

            // ML Predictions - Show all 24 hours
            if (mlForecast && mlForecast.predictions) {
                // Sort by target datetime and take first 24
                const sortedPredictions = [...mlForecast.predictions]
                    .sort((a, b) => a.target_datetime.localeCompare(b.target_datetime))
                    .slice(0, 24);

                if (sortedPredictions.length > 0) {
                    traces.push({
                        x: sortedPredictions.map(p => p.target_datetime),
                        y: sortedPredictions.map(p => p.cmg),
                        name: 'ü§ñ Predicci√≥n ML',
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: { color: '#3b82f6', width: 3, dash: 'dot' },
                        marker: { size: 6, color: '#3b82f6' }
                    });
                }
            }

            // CMG Programado (first node) - Show all 24 hours
            if (progForecast && progForecast.forecasts) {
                const firstNode = Object.keys(progForecast.forecasts)[0];
                if (firstNode) {
                    const forecasts = progForecast.forecasts[firstNode];
                    // Sort and take first 24
                    const sortedForecasts = [...forecasts]
                        .sort((a, b) => a.datetime.localeCompare(b.datetime))
                        .slice(0, 24);

                    if (sortedForecasts.length > 0) {
                        traces.push({
                            x: sortedForecasts.map(f => f.datetime),
                            y: sortedForecasts.map(f => f.cmg),
                            name: 'üìÖ CMG Programado',
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: '#8b5cf6', width: 2, dash: 'dash' },
                            marker: { size: 5 }
                        });
                    }
                }
            }

            // Actual CMG Online - Show actuals for the full 24h forecast window
            if (actualData && Object.keys(actualData).length > 0) {
                const firstNode = Object.keys(actualData)[0];
                if (actualData[firstNode] && actualData[firstNode].cmg_usd) {
                    const allCmgValues = actualData[firstNode].cmg_usd;
                    const filteredValues = [];
                    const filteredDatetimes = [];

                    // Start from t+1 (hour + 1)
                    const startHour = forecastHour + 1;

                    // Get actuals for same day (from t+1 to 23:00)
                    for (let h = startHour; h < 24; h++) {
                        if (allCmgValues[h] !== null && allCmgValues[h] !== undefined) {
                            filteredValues.push(allCmgValues[h]);
                            filteredDatetimes.push(`${forecastDate}T${h.toString().padStart(2, '0')}:00:00`);
                        }
                    }

                    // Try to get actuals for next day (from 00:00 to forecast hour)
                    const nextDate = new Date(forecastDate);
                    nextDate.setDate(nextDate.getDate() + 1);
                    const nextDateStr = nextDate.toISOString().split('T')[0];

                    if (historicalData && historicalData.daily_data && historicalData.daily_data[nextDateStr]) {
                        const nextDayData = historicalData.daily_data[nextDateStr];
                        if (nextDayData.cmg_online && nextDayData.cmg_online[firstNode]) {
                            const nextDayCmg = nextDayData.cmg_online[firstNode].cmg_usd;
                            // Get hours 0 to forecastHour (to complete 24h window)
                            for (let h = 0; h <= forecastHour; h++) {
                                if (nextDayCmg[h] !== null && nextDayCmg[h] !== undefined) {
                                    filteredValues.push(nextDayCmg[h]);
                                    filteredDatetimes.push(`${nextDateStr}T${h.toString().padStart(2, '0')}:00:00`);
                                }
                            }
                        }
                    }

                    if (filteredValues.length > 0) {
                        traces.push({
                            x: filteredDatetimes,
                            y: filteredValues,
                            name: '‚úÖ CMG Online (Real)',
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: '#10b981', width: 2 },
                            marker: { size: 6 }
                        });
                    }
                }
            }

            const layout = {
                title: {
                    text: `Pron√≥stico ${forecastDate} ${forecastHour.toString().padStart(2, '0')}:00 ‚Üí 24 horas (t+1 a t+24)`,
                    font: { size: 14 }
                },
                xaxis: { title: 'Fecha y Hora' },
                yaxis: { title: 'CMG (USD/MWh)' },
                showlegend: true,
                legend: { x: 0.02, y: 0.98 },
                hovermode: 'x unified',
                margin: { t: 40, r: 20, b: 60, l: 60 },
                autosize: true
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('comparison-chart', traces, layout, config).then(() => {
                setTimeout(() => {
                    Plotly.Plots.resize('comparison-chart');
                }, 100);
            });
        }

        function renderComparisonTable(date, hour, mlForecast, progForecast, actualData) {
            const table = document.getElementById('comparison-table');

            if (!mlForecast && !progForecast) {
                table.innerHTML = '<p class="text-gray-500">No hay pron√≥sticos disponibles para esta hora</p>';
                return;
            }

            // Use a Map to merge predictions by target datetime (avoids duplicates)
            const rowMap = new Map();
            const forecastDate = date;
            const forecastHour = parseInt(hour);

            // Helper: Get datetime key for merging (YYYY-MM-DD HH:00)
            function getDatetimeKey(datetimeStr) {
                if (!datetimeStr) return null;
                return datetimeStr.substring(0, 13) + ':00'; // "2025-11-24T14:00"
            }

            // Process ML predictions - show ALL 24 hours (t+1 to t+24)
            if (mlForecast && mlForecast.predictions) {
                // Sort and take first 24
                const sortedPreds = [...mlForecast.predictions]
                    .sort((a, b) => a.target_datetime.localeCompare(b.target_datetime))
                    .slice(0, 24);

                sortedPreds.forEach(pred => {
                    const key = getDatetimeKey(pred.target_datetime);
                    if (!key) return;

                    if (!rowMap.has(key)) {
                        rowMap.set(key, { datetime: key, ml: null, prog: null, actual: null });
                    }
                    rowMap.get(key).ml = pred;
                });
            }

            // Process CMG Programado - show ALL 24 hours, pick first node
            if (progForecast && progForecast.forecasts) {
                const firstNodeKey = Object.keys(progForecast.forecasts)[0];
                const progData = progForecast.forecasts[firstNodeKey] || [];

                // Sort and take first 24
                const sortedProg = [...progData]
                    .sort((a, b) => a.datetime.localeCompare(b.datetime))
                    .slice(0, 24);

                sortedProg.forEach(pred => {
                    const key = getDatetimeKey(pred.datetime);
                    if (!key) return;

                    if (!rowMap.has(key)) {
                        rowMap.set(key, { datetime: key, ml: null, prog: null, actual: null });
                    }
                    // Only set if not already set (avoid duplicates)
                    if (!rowMap.get(key).prog) {
                        rowMap.get(key).prog = pred;
                    }
                });
            }

            // Add actual CMG Online values for the 24h forecast window
            if (actualData) {
                const firstNode = Object.keys(actualData)[0];
                if (firstNode && actualData[firstNode] && actualData[firstNode].cmg_usd) {
                    const cmgValues = actualData[firstNode].cmg_usd;

                    // Same day actuals (from t+1 to 23:00)
                    for (let h = forecastHour + 1; h < 24; h++) {
                        if (cmgValues[h] !== null && cmgValues[h] !== undefined) {
                            const key = `${forecastDate}T${h.toString().padStart(2, '0')}:00`;
                            if (!rowMap.has(key)) {
                                rowMap.set(key, { datetime: key, ml: null, prog: null, actual: null });
                            }
                            rowMap.get(key).actual = cmgValues[h];
                        }
                    }

                    // Next day actuals (from 00:00 to forecastHour)
                    const nextDate = new Date(forecastDate);
                    nextDate.setDate(nextDate.getDate() + 1);
                    const nextDateStr = nextDate.toISOString().split('T')[0];

                    if (historicalData && historicalData.daily_data && historicalData.daily_data[nextDateStr]) {
                        const nextDayData = historicalData.daily_data[nextDateStr];
                        if (nextDayData.cmg_online && nextDayData.cmg_online[firstNode]) {
                            const nextDayCmg = nextDayData.cmg_online[firstNode].cmg_usd;
                            for (let h = 0; h <= forecastHour; h++) {
                                if (nextDayCmg[h] !== null && nextDayCmg[h] !== undefined) {
                                    const key = `${nextDateStr}T${h.toString().padStart(2, '0')}:00`;
                                    if (!rowMap.has(key)) {
                                        rowMap.set(key, { datetime: key, ml: null, prog: null, actual: null });
                                    }
                                    rowMap.get(key).actual = nextDayCmg[h];
                                }
                            }
                        }
                    }
                }
            }

            // Convert to sorted array (by datetime)
            const rows = Array.from(rowMap.values())
                .filter(row => row.ml || row.prog || row.actual) // Only rows with data
                .sort((a, b) => a.datetime.localeCompare(b.datetime));

            table.innerHTML = `
                <thead class="bg-gray-50 border-b-2 border-gray-200">
                    <tr>
                        <th class="px-3 py-2 text-left font-semibold text-gray-700">Fecha/Hora</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">ü§ñ ML</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700 text-xs">% CMG 0</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">üìÖ Programado</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">‚úÖ Real</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">Œî ML</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">Œî Prog</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                    ${rows.map(row => {
                        const mlValue = row.ml ? row.ml.cmg : null;
                        const probZero = row.ml ? row.ml.prob_zero : null;
                        const progValue = row.prog ? row.prog.cmg : null;
                        const actualValue = row.actual;

                        const mlError = (mlValue != null && actualValue != null) ? (mlValue - actualValue) : null;
                        const progError = (progValue != null && actualValue != null) ? (progValue - actualValue) : null;

                        // Color code probability: >70% = red (high risk), 30-70% = yellow, <30% = green
                        const probColor = probZero == null ? 'text-gray-400' :
                                         (probZero > 0.7 ? 'text-red-600' :
                                          probZero > 0.3 ? 'text-yellow-600' : 'text-green-600');

                        // Extract hour for display
                        const displayTime = row.datetime.substring(11, 16); // "HH:00"

                        return `
                        <tr class="hover:bg-gray-50">
                            <td class="px-3 py-2 font-medium">${row.datetime.substring(0, 10)} ${displayTime}</td>
                            <td class="px-3 py-2 text-right ${mlValue === 0 ? 'text-gray-500' : 'text-blue-700'} font-semibold">
                                ${mlValue != null ? `$${mlValue.toFixed(2)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${probColor} text-xs font-medium">
                                ${probZero != null ? `${(probZero * 100).toFixed(1)}%` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${progValue === 0 ? 'text-gray-500' : 'text-purple-700'} font-semibold">
                                ${progValue != null ? `$${progValue.toFixed(2)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${actualValue === 0 ? 'text-gray-500' : 'text-green-700'} font-semibold">
                                ${actualValue != null ? `$${actualValue.toFixed(2)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${mlError == null ? 'text-gray-400' : (Math.abs(mlError) < 5 ? 'text-green-600' : 'text-red-600')} text-xs">
                                ${mlError != null ? `${mlError > 0 ? '+' : ''}${mlError.toFixed(1)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${progError == null ? 'text-gray-400' : (Math.abs(progError) < 5 ? 'text-green-600' : 'text-red-600')} text-xs">
                                ${progError != null ? `${progError > 0 ? '+' : ''}${progError.toFixed(1)}` : '-'}
                            </td>
                        </tr>
                        `;
                    }).join('')}
                </tbody>
            `;

            // Add summary row with count
            if (rows.length > 0) {
                const mlCount = rows.filter(r => r.ml).length;
                const progCount = rows.filter(r => r.prog).length;
                const actualCount = rows.filter(r => r.actual !== null).length;
                console.log(`[Table] Showing ${rows.length} rows: ${mlCount} ML, ${progCount} Prog, ${actualCount} Actual (same-day only)`);
            }
        }

        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-container').classList.remove('hidden');
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('loading-container').classList.add('hidden');
        }
    </script>
</body>
</html>
