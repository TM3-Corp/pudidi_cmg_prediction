<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparaci√≥n de Pron√≥sticos - CMG Monitor</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Plotly for charts -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <!-- Supabase Client -->
    <script src="/js/supabase-client.js"></script>

    <style>
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-blue-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-lg">
        <div class="container mx-auto px-4 py-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">
                        üîÆ Comparaci√≥n de Pron√≥sticos
                    </h1>
                    <p class="text-gray-600 mt-2">
                        Visualiza pron√≥sticos hist√≥ricos y compara con valores reales
                    </p>
                </div>
                <div class="flex gap-2">
                    <a href="index.html"
                       class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                  d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                        </svg>
                        <span>Inicio</span>
                    </a>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container mx-auto px-4 py-8">

        <!-- Date/Hour Selector -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">üìÖ Seleccionar Pron√≥stico</h2>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Fecha</label>
                    <select id="date-selector" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="">Cargando fechas...</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Hora</label>
                    <select id="hour-selector" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="">Seleccionar primero una fecha</option>
                    </select>
                </div>
                <div class="flex items-end">
                    <button id="load-forecast-btn" onclick="loadForecast()"
                            class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg transition-colors font-semibold">
                        Cargar Pron√≥stico
                    </button>
                </div>
            </div>

            <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
                <h3 class="font-semibold text-blue-900 mb-2">‚ÑπÔ∏è C√≥mo Usar</h3>
                <p class="text-sm text-blue-800 mb-2">
                    Selecciona una fecha y hora espec√≠fica para ver qu√© pron√≥sticos se hicieron en ese momento.
                    Se mostrar√°n las predicciones ML, el CMG Programado, y los valores reales CMG Online (si est√°n disponibles).
                </p>
                <p class="text-sm text-blue-800">
                    <strong>Nota:</strong> Las matrices de pron√≥stico (ML y CMG Programado) se guardan autom√°ticamente cada hora.
                    Los datos hist√≥ricos se acumular√°n progresivamente con cada ciclo del workflow.
                </p>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loading-container" class="hidden bg-white rounded-xl shadow-lg p-8">
            <div class="flex flex-col items-center justify-center">
                <div class="loading-spinner mb-4"></div>
                <h2 class="text-xl font-semibold text-gray-700">
                    Cargando pron√≥sticos...
                </h2>
            </div>
        </div>

        <!-- Forecast Results -->
        <div id="results-container" class="hidden">
            <!-- Forecast Info -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">üìä Pron√≥stico Seleccionado</h2>
                <div id="forecast-info" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Will be populated -->
                </div>
            </div>

            <!-- Comparison Chart -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">üìà Comparaci√≥n Visual</h2>
                <div id="comparison-chart" style="height: 500px;"></div>
            </div>

            <!-- Unified Comparison Table -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">üìä Comparaci√≥n Detallada</h3>
                <div class="overflow-x-auto">
                    <table id="comparison-table" class="w-full text-sm">
                        <!-- Will be populated -->
                    </table>
                </div>
            </div>
        </div>

        <!-- Error State -->
        <div id="error-container" class="hidden bg-red-50 border border-red-200 rounded-lg p-6">
            <h3 class="text-red-900 font-bold mb-2">‚ùå Error</h3>
            <p id="error-message" class="text-red-800"></p>
        </div>

    </div>

    <script>
        let historicalData = null;

        // Load historical data on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await loadHistoricalData();
        });

        async function loadHistoricalData() {
            try {
                console.log('Loading historical comparison data from backend...');

                // Use backend API instead of direct Supabase access
                const response = await fetch('/api/historical_comparison');

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const apiData = await response.json();

                if (!apiData.success) {
                    throw new Error(apiData.message || 'Failed to load data');
                }

                console.log('API Response:', apiData);

                // Transform API data to expected structure
                const mlData = transformMLPredictionsFromAPI(apiData.data.ml_predictions);
                const progData = transformCMGProgramadoFromAPI(apiData.data.cmg_programado);
                const onlineData = transformCMGOnlineFromAPI(apiData.data.cmg_online);

                // Merge the 3 data sources into unified structure
                historicalData = mergeGistData(mlData, progData, onlineData);

                console.log('Merged historical data:', historicalData);
                populateDateSelector();
            } catch (error) {
                console.error('Error loading historical data:', error);
                showError('No se pudo cargar los datos hist√≥ricos. Por favor, intenta m√°s tarde.');
            }
        }

        function transformMLPredictionsFromAPI(mlByForecast) {
            const daily_data = {};

            // ML predictions are grouped by forecast_datetime
            // We organize by the FORECAST date/hour (when the prediction was made)
            for (const [forecastTime, predictions] of Object.entries(mlByForecast)) {
                const forecastDate = new Date(forecastTime);
                const dateKey = forecastDate.toISOString().split('T')[0];
                const hour = forecastDate.getHours();

                if (!daily_data[dateKey]) {
                    daily_data[dateKey] = {
                        ml_forecasts: {}
                    };
                }

                // Store predictions under the hour when the forecast was made
                daily_data[dateKey].ml_forecasts[hour] = {
                    forecast_time: forecastTime,
                    model_version: predictions[0]?.model_version || 'v2.0',
                    predictions: predictions.map(pred => ({
                        horizon: pred.horizon,
                        target_datetime: pred.target_datetime,
                        cmg: pred.predicted_cmg,
                        prob_zero: pred.prob_zero || 0,
                        threshold: pred.threshold || 0.5
                    }))
                };
            }

            return { daily_data };
        }

        function transformCMGProgramadoFromAPI(programadoArray) {
            const daily_data = {};

            // Group by date and hour to create forecast snapshots
            const byDateHour = {};
            programadoArray.forEach(record => {
                const dt = new Date(record.datetime);
                const dateKey = dt.toISOString().split('T')[0];
                const hour = dt.getHours();
                const key = `${dateKey}_${hour}`;

                if (!byDateHour[key]) {
                    byDateHour[key] = { date: dateKey, hour: hour, records: [] };
                }
                byDateHour[key].records.push(record);
            });

            // Transform into forecast snapshots structure
            Object.values(byDateHour).forEach(snapshot => {
                const { date, hour, records } = snapshot;

                if (!daily_data[date]) {
                    daily_data[date] = {
                        cmg_programado_forecasts: {}  // FIXED: Changed from 'cmg_programado' to 'cmg_programado_forecasts'
                    };
                }

                // Create forecast snapshot for this hour
                const forecasts = {};
                records.forEach(record => {
                    const node = record.node;
                    if (!forecasts[node]) {
                        forecasts[node] = [];
                    }
                    forecasts[node].push({
                        datetime: record.datetime,
                        cmg: record.cmg_programmed
                    });
                });

                // Sort forecasts by datetime
                Object.values(forecasts).forEach(nodeForecasts => {
                    nodeForecasts.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));
                });

                daily_data[date].cmg_programado_forecasts[hour] = {
                    fetched_at: `${date}T${hour.toString().padStart(2, '0')}:00:00`,
                    forecasts: forecasts
                };
            });

            return { daily_data };
        }

        function transformCMGOnlineFromAPI(onlineArray) {
            const daily_data = {};

            onlineArray.forEach(record => {
                const dt = new Date(record.datetime);
                const dateKey = dt.toISOString().split('T')[0];
                const hour = dt.getHours();

                if (!daily_data[dateKey]) {
                    daily_data[dateKey] = {
                        hours: [],
                        cmg_online: {}
                    };
                }

                if (!daily_data[dateKey].cmg_online[record.node]) {
                    daily_data[dateKey].cmg_online[record.node] = {
                        cmg_usd: Array(24).fill(null)
                    };
                }

                daily_data[dateKey].cmg_online[record.node].cmg_usd[hour] = record.cmg_actual;

                if (!daily_data[dateKey].hours.includes(hour)) {
                    daily_data[dateKey].hours.push(hour);
                }
            });

            // Sort hours for each day
            for (const dateKey in daily_data) {
                daily_data[dateKey].hours.sort((a, b) => a - b);
            }

            return { daily_data };
        }

        function transformMLPredictions(records) {
            const daily_data = {};

            records.forEach(record => {
                const forecastTime = new Date(record.forecast_datetime);
                const date = forecastTime.toISOString().split('T')[0];
                const hour = forecastTime.getUTCHours();

                if (!daily_data[date]) {
                    daily_data[date] = { ml_forecasts: {} };
                }
                if (!daily_data[date].ml_forecasts[hour]) {
                    daily_data[date].ml_forecasts[hour] = {
                        forecast_time: record.forecast_datetime,
                        model_version: record.model_version || 'v2.0',
                        predictions: []
                    };
                }

                daily_data[date].ml_forecasts[hour].predictions.push({
                    horizon: record.horizon,
                    target_datetime: record.target_datetime,
                    cmg: record.cmg_predicted,
                    prob_zero: record.prob_zero || 0,
                    threshold: record.threshold || 0.5
                });
            });

            // Sort predictions by horizon
            Object.values(daily_data).forEach(day => {
                Object.values(day.ml_forecasts).forEach(forecast => {
                    forecast.predictions.sort((a, b) => a.horizon - b.horizon);
                });
            });

            return {
                metadata: {
                    last_update: new Date().toISOString(),
                    total_forecasts: records.length,
                    source: 'supabase'
                },
                daily_data
            };
        }

        function transformCMGProgramado(records) {
            const daily_data = {};

            // Group by fetched_at (the forecast snapshot time)
            const snapshots = {};
            records.forEach(record => {
                const fetchedAt = record.fetched_at || record.created_at;
                if (!snapshots[fetchedAt]) {
                    snapshots[fetchedAt] = [];
                }
                snapshots[fetchedAt].push(record);
            });

            // Transform each snapshot
            Object.entries(snapshots).forEach(([fetchedAt, snapshotRecords]) => {
                const fetchedTime = new Date(fetchedAt);
                const date = fetchedTime.toISOString().split('T')[0];
                const hour = fetchedTime.getUTCHours();

                if (!daily_data[date]) {
                    daily_data[date] = { cmg_programado_forecasts: {} };
                }

                const forecasts = {};
                snapshotRecords.forEach(record => {
                    const node = record.node || 'PMontt220';
                    if (!forecasts[node]) {
                        forecasts[node] = [];
                    }
                    forecasts[node].push({
                        datetime: record.datetime,
                        cmg: record.cmg_programmed
                    });
                });

                // Sort forecasts by datetime
                Object.values(forecasts).forEach(nodeForecasts => {
                    nodeForecasts.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));
                });

                daily_data[date].cmg_programado_forecasts[hour] = {
                    fetched_at: fetchedAt,
                    forecasts
                };
            });

            return {
                metadata: {
                    last_update: new Date().toISOString(),
                    total_records: records.length,
                    source: 'supabase'
                },
                daily_data
            };
        }

        function transformCMGOnline(records) {
            const daily_data = {};

            records.forEach(record => {
                const date = record.date;
                const hour = record.hour;
                const node = record.node;

                if (!daily_data[date]) {
                    daily_data[date] = {
                        hours: [],
                        cmg_online: {}
                    };
                }

                if (!daily_data[date].cmg_online[node]) {
                    daily_data[date].cmg_online[node] = {
                        cmg_usd: new Array(24).fill(null)
                    };
                }

                daily_data[date].cmg_online[node].cmg_usd[hour] = record.cmg_usd;

                if (!daily_data[date].hours.includes(hour)) {
                    daily_data[date].hours.push(hour);
                    daily_data[date].hours.sort((a, b) => a - b);
                }
            });

            return {
                metadata: {
                    last_update: new Date().toISOString(),
                    total_records: records.length,
                    source: 'supabase'
                },
                daily_data
            };
        }

        function mergeGistData(mlData, progData, onlineData) {
            // Start with CMG Online as base (30-day window)
            const merged = {
                metadata: {
                    ...onlineData.metadata,
                    last_update: new Date().toISOString(),
                    structure_version: '3.0'
                },
                daily_data: {}
            };

            // Merge CMG Online data (actual values)
            if (onlineData.daily_data) {
                for (const [date, data] of Object.entries(onlineData.daily_data)) {
                    merged.daily_data[date] = {
                        hours: data.hours || [],
                        cmg_online: data.cmg_online || {},
                        ml_forecasts: {},
                        cmg_programado_forecasts: {}
                    };
                }
            }

            // Merge ML predictions (7-day window)
            if (mlData.daily_data) {
                for (const [date, data] of Object.entries(mlData.daily_data)) {
                    if (!merged.daily_data[date]) {
                        merged.daily_data[date] = {
                            hours: [],
                            cmg_online: {},
                            ml_forecasts: {},
                            cmg_programado_forecasts: {}
                        };
                    }
                    merged.daily_data[date].ml_forecasts = data.ml_forecasts || {};
                }
            }

            // Merge CMG Programado forecasts (7-day window)
            if (progData.daily_data) {
                for (const [date, data] of Object.entries(progData.daily_data)) {
                    if (!merged.daily_data[date]) {
                        merged.daily_data[date] = {
                            hours: [],
                            cmg_online: {},
                            ml_forecasts: {},
                            cmg_programado_forecasts: {}
                        };
                    }
                    merged.daily_data[date].cmg_programado_forecasts = data.cmg_programado_forecasts || {};
                }
            }

            return merged;
        }

        function populateDateSelector() {
            const dateSelector = document.getElementById('date-selector');
            const hourSelector = document.getElementById('hour-selector');

            if (!historicalData || !historicalData.daily_data) {
                dateSelector.innerHTML = '<option value="">No hay datos disponibles</option>';
                return;
            }

            // Get available dates with forecast matrices OR any CMG data
            // This makes it backward compatible with v2.0 structure
            const datesWithForecasts = Object.keys(historicalData.daily_data)
                .filter(date => {
                    const day = historicalData.daily_data[date];
                    // v3.0: Has new forecast matrices
                    const hasV3Forecasts = day.ml_forecasts || day.cmg_programado_forecasts;
                    // v2.0: Has any CMG data
                    const hasV2Data = day.cmg_online || day.cmg_programado;
                    return hasV3Forecasts || hasV2Data;
                })
                .sort()
                .reverse();

            if (datesWithForecasts.length === 0) {
                dateSelector.innerHTML = '<option value="">No hay pron√≥sticos disponibles</option>';
                return;
            }

            dateSelector.innerHTML = '<option value="">Seleccionar fecha</option>' +
                datesWithForecasts.map(date =>
                    `<option value="${date}">${date}</option>`
                ).join('');

            // Handle date selection
            dateSelector.addEventListener('change', function() {
                const selectedDate = this.value;
                if (!selectedDate) {
                    hourSelector.innerHTML = '<option value="">Seleccionar primero una fecha</option>';
                    return;
                }

                const dayData = historicalData.daily_data[selectedDate];
                const availableHours = new Set();

                // v3.0: Get hours from forecast matrices
                if (dayData.ml_forecasts) {
                    Object.keys(dayData.ml_forecasts).forEach(h => availableHours.add(parseInt(h)));
                }
                if (dayData.cmg_programado_forecasts) {
                    Object.keys(dayData.cmg_programado_forecasts).forEach(h => availableHours.add(parseInt(h)));
                }

                // v2.0: If no forecast matrices, show all hours from CMG Online
                if (availableHours.size === 0 && dayData.cmg_online) {
                    // Add hours that have data in any node
                    Object.values(dayData.cmg_online).forEach(nodeData => {
                        if (nodeData.cmg_usd) {
                            nodeData.cmg_usd.forEach((val, idx) => {
                                if (val !== null) availableHours.add(idx);
                            });
                        }
                    });
                }

                // If still no hours, show message
                if (availableHours.size === 0) {
                    hourSelector.innerHTML = '<option value="">No hay datos para esta fecha</option>';
                    return;
                }

                const hours = Array.from(availableHours).sort((a, b) => a - b);

                hourSelector.innerHTML = '<option value="">Seleccionar hora</option>' +
                    hours.map(hour =>
                        `<option value="${hour}">${hour.toString().padStart(2, '0')}:00</option>`
                    ).join('');
            });
        }

        async function loadForecast() {
            const date = document.getElementById('date-selector').value;
            const hour = document.getElementById('hour-selector').value;

            if (!date || hour === '') {
                showError('Por favor, selecciona una fecha y hora');
                return;
            }

            // Show loading
            document.getElementById('loading-container').classList.remove('hidden');
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('error-container').classList.add('hidden');

            try {
                const dayData = historicalData.daily_data[date];
                const mlForecast = dayData.ml_forecasts ? dayData.ml_forecasts[hour] : null;
                const progForecast = dayData.cmg_programado_forecasts ? dayData.cmg_programado_forecasts[hour] : null;
                const actualData = dayData.cmg_online || {};

                // Render forecast info
                renderForecastInfo(date, hour, mlForecast, progForecast);

                // Render comparison chart
                renderComparisonChart(date, hour, mlForecast, progForecast, actualData);

                // Render unified comparison table
                renderComparisonTable(date, hour, mlForecast, progForecast, actualData);

                // Hide loading, show results
                document.getElementById('loading-container').classList.add('hidden');
                document.getElementById('results-container').classList.remove('hidden');

            } catch (error) {
                console.error('Error loading forecast:', error);
                showError('Error al cargar el pron√≥stico: ' + error.message);
                document.getElementById('loading-container').classList.add('hidden');
            }
        }

        function renderForecastInfo(date, hour, mlForecast, progForecast) {
            const container = document.getElementById('forecast-info');

            const hourStr = hour.toString().padStart(2, '0');

            container.innerHTML = `
                <div>
                    <h3 class="text-sm font-medium text-gray-500 mb-1">Fecha y Hora</h3>
                    <p class="text-xl font-bold text-blue-600">${date} ${hourStr}:00</p>
                </div>
                <div>
                    <h3 class="text-sm font-medium text-gray-500 mb-1">Predicciones ML</h3>
                    <p class="text-xl font-bold ${mlForecast ? 'text-green-600' : 'text-yellow-600'}">
                        ${mlForecast ? `‚úÖ ${mlForecast.predictions.length} pron√≥sticos` : '‚è≥ Pendiente'}
                    </p>
                    ${!mlForecast ? '<p class="text-xs text-yellow-700 mt-1">Se guardar√° en el pr√≥ximo ciclo horario</p>' : ''}
                </div>
                <div>
                    <h3 class="text-sm font-medium text-gray-500 mb-1">CMG Programado</h3>
                    <p class="text-xl font-bold ${progForecast ? 'text-purple-600' : 'text-yellow-600'}">
                        ${progForecast ? `‚úÖ Disponible` : '‚è≥ Pendiente'}
                    </p>
                    ${!progForecast ? '<p class="text-xs text-yellow-700 mt-1">Se guardar√° en el pr√≥ximo ciclo horario</p>' : ''}
                </div>
            `;
        }

        function renderComparisonChart(date, hour, mlForecast, progForecast, actualData) {
            const traces = [];

            // ML Predictions
            if (mlForecast && mlForecast.predictions) {
                traces.push({
                    x: mlForecast.predictions.map(p => p.target_datetime),
                    y: mlForecast.predictions.map(p => p.cmg),
                    name: 'ü§ñ Predicci√≥n ML',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: '#3b82f6', width: 3, dash: 'dot' },
                    marker: { size: 6, color: '#3b82f6' }
                });
            }

            // CMG Programado (first node for simplicity) - Filter to show only t+1 onwards
            if (progForecast && progForecast.forecasts) {
                const firstNode = Object.keys(progForecast.forecasts)[0];
                if (firstNode) {
                    const forecasts = progForecast.forecasts[firstNode];

                    // Calculate t+1: selected hour + 1
                    const selectedHour = parseInt(hour);
                    const t1DateTime = `${date}T${(selectedHour + 1).toString().padStart(2, '0')}:00:00`;

                    // Filter to show only from t+1 onwards (skip t+0 if present)
                    const filteredForecasts = forecasts.filter(f => f.datetime >= t1DateTime);

                    if (filteredForecasts.length > 0) {
                        traces.push({
                            x: filteredForecasts.map(f => f.datetime),
                            y: filteredForecasts.map(f => f.cmg),
                            name: 'üìÖ CMG Programado',
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: '#8b5cf6', width: 2, dash: 'dash' },
                            marker: { size: 5 }
                        });
                    }
                }
            }

            // Actual CMG Online (if available) - Start from t+1
            if (actualData && Object.keys(actualData).length > 0) {
                const firstNode = Object.keys(actualData)[0];
                if (actualData[firstNode] && actualData[firstNode].cmg_usd) {
                    const allCmgValues = actualData[firstNode].cmg_usd;

                    // Start from t+1 (hour + 1), not from 00:00
                    const startHour = parseInt(hour) + 1;

                    // Filter to show only from t+1 onwards (within the selected day)
                    const filteredValues = [];
                    const filteredDatetimes = [];

                    for (let h = startHour; h < 24; h++) {
                        if (allCmgValues[h] !== null && allCmgValues[h] !== undefined) {
                            filteredValues.push(allCmgValues[h]);
                            filteredDatetimes.push(`${date}T${h.toString().padStart(2, '0')}:00:00`);
                        }
                    }

                    if (filteredValues.length > 0) {
                        traces.push({
                            x: filteredDatetimes,
                            y: filteredValues,
                            name: '‚úÖ CMG Online (Real)',
                            type: 'scatter',
                            mode: 'lines+markers',
                            line: { color: '#10b981', width: 2 },
                            marker: { size: 6 }
                        });
                    }
                }
            }

            const layout = {
                xaxis: { title: 'Fecha y Hora' },
                yaxis: { title: 'CMG (USD/MWh)' },
                showlegend: true,
                legend: { x: 0.02, y: 0.98 },
                hovermode: 'x unified',
                margin: { t: 20, r: 20, b: 60, l: 60 },
                autosize: true
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('comparison-chart', traces, layout, config).then(() => {
                // Force resize after render to ensure full width is used
                setTimeout(() => {
                    Plotly.Plots.resize('comparison-chart');
                }, 100);
            });
        }

        function renderComparisonTable(date, hour, mlForecast, progForecast, actualData) {
            const table = document.getElementById('comparison-table');

            if (!mlForecast && !progForecast) {
                table.innerHTML = '<p class="text-gray-500">No hay pron√≥sticos disponibles para esta hora</p>';
                return;
            }

            // Build unified data structure
            const rows = [];
            const maxLength = Math.max(
                mlForecast ? mlForecast.predictions.length : 0,
                progForecast ? (progForecast.forecasts ? Object.values(progForecast.forecasts)[0].length : 0) : 0
            );

            const progData = progForecast && progForecast.forecasts ? Object.values(progForecast.forecasts)[0] : null;

            for (let i = 0; i < maxLength; i++) {
                const mlPred = mlForecast && mlForecast.predictions[i];
                const progPred = progData && progData[i];

                // Determine the datetime for this row
                const rowDatetime = mlPred ? mlPred.target_datetime : (progPred ? progPred.datetime : null);

                // Get actual CMG Online value if available (for ANY row, not just those with ML predictions)
                let actualValue = null;
                if (rowDatetime && actualData) {
                    const targetDateTime = new Date(rowDatetime);
                    const targetDate = targetDateTime.toISOString().split('T')[0];
                    const targetHour = targetDateTime.getHours();

                    // Check if we have actual data for this datetime
                    const firstNode = Object.keys(actualData)[0];
                    if (firstNode && actualData[firstNode] && actualData[firstNode].cmg_usd) {
                        const dayData = historicalData.daily_data[targetDate];
                        if (dayData && dayData.cmg_online && dayData.cmg_online[firstNode]) {
                            actualValue = dayData.cmg_online[firstNode].cmg_usd[targetHour];
                        }
                    }
                }

                rows.push({
                    datetime: rowDatetime || '',
                    ml: mlPred,
                    prog: progPred,
                    actual: actualValue,
                    horizon: mlPred ? mlPred.horizon : null
                });
            }

            table.innerHTML = `
                <thead class="bg-gray-50 border-b-2 border-gray-200">
                    <tr>
                        <th class="px-3 py-2 text-left font-semibold text-gray-700">Fecha/Hora</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">ü§ñ ML</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700 text-xs">% CMG 0</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">üìÖ Programado</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">‚úÖ Real</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">Œî ML</th>
                        <th class="px-3 py-2 text-right font-semibold text-gray-700">Œî Prog</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                    ${rows.map(row => {
                        const mlValue = row.ml ? row.ml.cmg : null;
                        const probZero = row.ml ? row.ml.prob_zero : null;
                        const progValue = row.prog ? row.prog.cmg : null;
                        const actualValue = row.actual;

                        const mlError = (mlValue !== null && actualValue !== null) ? (mlValue - actualValue) : null;
                        const progError = (progValue !== null && actualValue !== null) ? (progValue - actualValue) : null;

                        // Color code probability: >70% = red (high risk), 30-70% = yellow, <30% = green
                        const probColor = probZero === null ? 'text-gray-400' :
                                         (probZero > 0.7 ? 'text-red-600' :
                                          probZero > 0.3 ? 'text-yellow-600' : 'text-green-600');

                        return `
                        <tr class="hover:bg-gray-50">
                            <td class="px-3 py-2 font-medium">${row.datetime.substring(0, 16).replace('T', ' ')}</td>
                            <td class="px-3 py-2 text-right ${mlValue === 0 ? 'text-gray-500' : 'text-blue-700'} font-semibold">
                                ${mlValue !== null ? `$${mlValue.toFixed(2)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${probColor} text-xs font-medium">
                                ${probZero !== null ? `${(probZero * 100).toFixed(1)}%` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${progValue === 0 ? 'text-gray-500' : 'text-purple-700'} font-semibold">
                                ${progValue !== null ? `$${progValue.toFixed(2)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${actualValue === 0 ? 'text-gray-500' : 'text-green-700'} font-semibold">
                                ${actualValue !== null ? `$${actualValue.toFixed(2)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${mlError === null ? 'text-gray-400' : (Math.abs(mlError) < 5 ? 'text-green-600' : 'text-red-600')} text-xs">
                                ${mlError !== null ? `${mlError > 0 ? '+' : ''}${mlError.toFixed(1)}` : '-'}
                            </td>
                            <td class="px-3 py-2 text-right ${progError === null ? 'text-gray-400' : (Math.abs(progError) < 5 ? 'text-green-600' : 'text-red-600')} text-xs">
                                ${progError !== null ? `${progError > 0 ? '+' : ''}${progError.toFixed(1)}` : '-'}
                            </td>
                        </tr>
                        `;
                    }).join('')}
                </tbody>
            `;
        }

        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-container').classList.remove('hidden');
            document.getElementById('results-container').classList.add('hidden');
            document.getElementById('loading-container').classList.add('hidden');
        }
    </script>
</body>
</html>
